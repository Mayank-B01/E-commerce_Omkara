let EsewaPaymentGateway, EsewaCheckStatus, base64Decode;

(async () => {
  const esewa = await import('esewajs');
  EsewaPaymentGateway = esewa.EsewaPaymentGateway;
  EsewaCheckStatus = esewa.EsewaCheckStatus;
  base64Decode = esewa.base64Decode;
})();
const crypto = require('crypto');
const Order = require('../models/orderModel'); // Import Order model
const userModel = require('../models/userModel'); // Import User model
const PendingOrder = require('../models/pendingOrderModel'); // Import PendingOrder model
const productModel = require('../models/productModel'); // Import Product model for price check

const generateSignature = (message, secret) => {
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(message);
    return hmac.digest('base64');
};

const EsewaInitiatePayment = async (req, res) => {
    
    // Expect selectedItems array instead of amount
    const { selectedItems, orderId: frontendOrderId } = req.body; // Rename incoming orderId
    const userId = req.user.id; // Get userId from requireSignIn middleware

    const successUrl = process.env.SUCCESS_URL; 
    const failureUrl = process.env.FAILURE_URL; 

    console.log(`[eSewa Initiate] Received Order ID from frontend: ${frontendOrderId}`);
    console.log(`[eSewa Initiate] Received ${selectedItems?.length || 0} selected items for user ${userId}.`);

    // --- Validation ---
    if (!selectedItems || !Array.isArray(selectedItems) || selectedItems.length === 0) {
        console.error("[eSewa Initiate] Error: No selected items provided.");
        return res.status(400).json({ success: false, message: "No items selected for checkout." });
    }
     // Validate environment variables (as before)
    if (!process.env.MERCHANT_ID || !process.env.SECRET || !successUrl || !failureUrl || !process.env.ESEWAPAYMENT_URL) {
        console.error("[eSewa Initiate] Error: Missing required eSewa environment variables.");
        return res.status(500).json({ success: false, message: "Payment gateway configuration error." });
    }

    let serverCalculatedAmount = 0;
    const validatedItems = [];

    try {
        // --- Server-side Amount Calculation & Item Validation ---
        for (const item of selectedItems) {
            if (!item.productId || !item.quantity || item.quantity <= 0) {
                throw new Error(`Invalid item data received: ${JSON.stringify(item)}`);
            }

            const product = await productModel.findById(item.productId);
            if (!product) {
                throw new Error(`Product with ID ${item.productId} not found.`);
            }
            // Optional: Add stock check here if needed
            // if (product.quantity < item.quantity) { ... }

            const itemPrice = product.price;
            serverCalculatedAmount += itemPrice * item.quantity;
            
            validatedItems.push({
                product: product._id, // Store ObjectId
                quantity: item.quantity,
                size: item.size,       // Include size if provided
                price: itemPrice      // Store validated price
            });
        }

        if (serverCalculatedAmount <= 0) {
             throw new Error("Calculated total amount is zero or negative.");
        }
        // Round to 2 decimal places if necessary for eSewa
        serverCalculatedAmount = parseFloat(serverCalculatedAmount.toFixed(2));

        console.log(`[eSewa Initiate] Server calculated amount: ${serverCalculatedAmount}`);

        // --- Create Unique Order ID (use the one from frontend if robust, or generate new) ---
        // Using the frontend one allows linking logs, but ensure it's unique enough
        // Format: OMK-timestamp-userId (last 4 chars)
        const uniqueOrderId = frontendOrderId; // Use the ID generated by frontend
         console.log(`[eSewa Initiate] Using Order ID: ${uniqueOrderId}`);

        // --- Store Pending Order --- 
        // Remove existing pending order for this ID if any (prevents issues on retry)
        await PendingOrder.deleteOne({ orderId: uniqueOrderId }); 
        const pendingOrder = new PendingOrder({
            orderId: uniqueOrderId,
            items: validatedItems,
            userId: userId
        });
        await pendingOrder.save();
        console.log(`[eSewa Initiate] Pending order ${uniqueOrderId} saved to DB.`);

        // --- Call eSewa Gateway ---
        console.log(`[eSewa Initiate] Calling EsewaPaymentGateway for Order ID: ${uniqueOrderId}`);
        const reqPayment = await EsewaPaymentGateway(
            serverCalculatedAmount, // Use server-calculated amount
            0, 0, 0, 
            uniqueOrderId,         // Use our generated unique ID
            process.env.MERCHANT_ID,
            process.env.SECRET,
            successUrl,      
            failureUrl,     
            process.env.ESEWAPAYMENT_URL,
            undefined, undefined
        );

        if (!reqPayment || reqPayment.status !== 200 || !reqPayment.request?.res?.responseUrl) {
            console.error("[eSewa Initiate] Error: Failed to initiate payment via EsewaPaymentGateway. Response:", reqPayment);
             // Clean up pending order if gateway fails
            await PendingOrder.deleteOne({ orderId: uniqueOrderId });
            return res.status(500).json({ success: false, message: "Error initiating payment with gateway." });
        }

        console.log(`[eSewa Initiate] Success! Redirecting user to eSewa for Order ID: ${uniqueOrderId}`);
        return res.status(200).send({
            success: true,
            message: "Redirect URL generated.",
            url: reqPayment.request.res.responseUrl,
        });

    } catch (error) {
        console.error(`[eSewa Initiate] Error during payment initiation:`, error);
        // Attempt cleanup of pending order if validation/DB fails before gateway call
        if (uniqueOrderId) { 
            await PendingOrder.deleteOne({ orderId: uniqueOrderId }).catch(err => console.error("Cleanup Error:", err));
        }
        return res.status(500).json({ success: false, message: error.message || "Internal server error during payment initiation." });
    }
};


const paymentStatus = async (req, res) => {
    
    const { orderId } = req.body;
    console.log(`[eSewa Status Check] Received request for Order ID: ${orderId}`);

    if (!orderId) {
        return res.status(400).json({ success: false, message: "Order ID is required." });
    }

    try {
        const transaction = { amount: 0, status: 'not_found' }; // Placeholder - Replace with DB Query
        if (!transaction || transaction.status === 'not_found') {
            console.warn(`[eSewa Status Check] Transaction not found in DB for Order ID: ${orderId}`);
            return res.status(404).json({ success: false, message: "Transaction not found" });
        }
        if (transaction.status === 'completed') {
             console.log(`[eSewa Status Check] Transaction ${orderId} already marked completed in DB.`);
            return res.status(200).json({ success: true, status: transaction.status, message: "Transaction already completed." });
        }

        console.log(`[eSewa Status Check] Calling EsewaCheckStatus API for Order ID: ${orderId}, Amount: ${transaction.amount}`);
        const paymentStatusCheck = await EsewaCheckStatus(
            transaction.amount,
            orderId,
            process.env.MERCHANT_ID,
            process.env.ESEWAPAYMENT_STATUS_CHECK_URL
        );

        console.log(`[eSewa Status Check] API Response for ${orderId}:`, paymentStatusCheck);

        if (paymentStatusCheck.status === 200 && paymentStatusCheck.data?.status) {
            const esewaStatus = paymentStatusCheck.data.status;
            console.log(`[eSewa Status Check] eSewa API reported status '${esewaStatus}' for Order ID: ${orderId}`)

            res.status(200).json({
                success: true,
                status: esewaStatus,
                message: "Transaction status retrieved successfully."
            });
        } else {
            console.error(`[eSewa Status Check] Failed to get valid status from eSewa API for Order ID ${orderId}. Response:`, paymentStatusCheck);
            res.status(500).json({ success: false, message: "Failed to verify payment status with gateway." });
        }
    } catch (error) {
        console.error(`[eSewa Status Check] Error updating transaction status for Order ID ${orderId}:`, error);
        res.status(500).json({ success: false, message: "Server error during status check.", error: error.message });
    }
};


const handleEsewaSuccessCallback = async (req, res) => {
    // --- Add log here to check if SECRET is loaded ---
    console.log(`[eSewa Success DEBUG] Function start. Checking loaded SECRET: ${process.env.SECRET ? process.env.SECRET.substring(0, 4) + "..." : "SECRET IS UNDEFINED"}`);
    const clientUrl = process.env.CLIENT_URL || 'http://localhost:5173';
    let esewaOrderId = 'UNKNOWN'; // Use a distinct name for the ID from eSewa

    try {
        console.log("[eSewa Success Callback] Received request. Query:", req.query);
        const { data } = req.query;

        if (!data) {
            console.error("[eSewa Success Callback] Error: 'data' parameter missing.");
            return res.redirect(`${clientUrl}/cart?payment_status=failure&message=InvalidCallbackResponse`);
        }

        let decodedData;
        try {
            decodedData = base64Decode(data);
            console.log("[eSewa Success Callback] Decoded Data:", decodedData);
        } catch (decodeError) {
             console.error("[eSewa Success Callback] Error decoding Base64 data:", decodeError);
             return res.redirect(`${clientUrl}/cart?payment_status=failure&message=InvalidCallbackDataFormat`);
        }

        // Extract relevant fields from decoded data
        const { 
            transaction_uuid, // This is our uniqueOrderId (e.g., OMK-timestamp-userId)
            status, 
            total_amount, 
            signature: receivedSignature, 
            signed_field_names, 
            transaction_code, 
            product_code 
        } = decodedData;
        
        esewaOrderId = transaction_uuid;

        // 1. Verify Status
        if (status !== 'COMPLETE') {
            console.warn(`[eSewa Success Callback] Warning: Transaction ${esewaOrderId} status is '${status}', not 'COMPLETE'. Treating as failure.`);
            return res.redirect(`${clientUrl}/cart?payment_status=failure&orderId=${esewaOrderId}&message=PaymentNotCompleted&status=${status}`);
        }

        // 2. Verify Signature
        // --- Corrected amount handling for verification string ---
        const amountStringForVerification = String(total_amount).replace(/,/g, ''); // Remove commas
        const verification_string = `transaction_code=${transaction_code},status=${status},total_amount=${amountStringForVerification},transaction_uuid=${transaction_uuid},product_code=${product_code},signed_field_names=${signed_field_names}`;
        const calculatedSignature = generateSignature(verification_string, process.env.SECRET);

        // ---- START DEBUG LOGGING ----
        console.log("[eSewa Success DEBUG] Received Signature:", receivedSignature);
        console.log("[eSewa Success DEBUG] Calculated Signature:", calculatedSignature);
        console.log("[eSewa Success DEBUG] Verification String:", verification_string);
        console.log("[eSewa Success DEBUG] Using Secret starting with:", process.env.SECRET ? process.env.SECRET.substring(0, 4) + "..." : "UNDEFINED"); // Log first few chars of secret
        console.log("[eSewa Success DEBUG] Decoded product_code:", product_code);
        // ---- END DEBUG LOGGING ----

        console.log("[eSewa Success Callback] Verification String:", verification_string);
        console.log("[eSewa Success Callback] Received Signature:", receivedSignature);
        console.log("[eSewa Success Callback] Calculated Signature:", calculatedSignature);

        if (calculatedSignature !== receivedSignature) {
            console.error(`[eSewa Success Callback] Error: Signature verification FAILED for order ${esewaOrderId}!`);
            console.log(`[eSewa Success DEBUG] Signatures DO NOT MATCH. Redirecting with SignatureMismatch.`);
            return res.redirect(`${clientUrl}/cart?payment_status=failure&orderId=${esewaOrderId}&message=SignatureMismatch`);
        }

        console.log(`[eSewa Success Callback] Signature verified successfully for order ${esewaOrderId}.`);

        let dbErrorOccurred = false;
        // Default redirect to cart page with generic error
        let finalRedirectUrl = `${clientUrl}/cart?payment_status=failure&orderId=${esewaOrderId}&message=OrderProcessingError`;

        try {
            // 3. Check if ACTUAL Order Already Exists (using transaction_uuid)
             const existingOrder = await Order.findOne({ 'payment.transaction_uuid': esewaOrderId });
             if (existingOrder) {
                 console.warn(`[eSewa Success Callback] Order already processed for transaction_uuid: ${esewaOrderId}. Redirecting to success.`);
                 finalRedirectUrl = `${clientUrl}/?payment_status=success&orderId=${esewaOrderId}`; 
             } else {
                 // 4. Fetch the PendingOrder using the transaction_uuid (our orderId)
                 const pendingOrder = await PendingOrder.findOne({ orderId: esewaOrderId });
                 if (!pendingOrder) {
                     // This shouldn't happen if initiation worked, maybe TTL expired?
                      throw new Error(`Pending order not found for ID: ${esewaOrderId}. Payment might have expired.`);
                 }
                 console.log(`[eSewa Success Callback] Found pending order for ${esewaOrderId}`);

                 const userId = pendingOrder.userId;
                 const itemsToOrder = pendingOrder.items; // Get items from pending order

                 // 5. Find the User
                 const user = await userModel.findById(userId);
                 if (!user) {
                     // Should not happen if pending order exists, but check anyway
                     throw new Error(`User not found for ID: ${userId} associated with pending order ${esewaOrderId}`);
                 }

                 console.log(`[eSewa Success Callback] Found user ${user.email}. Items to order: ${itemsToOrder.length}`);

                 // 6. Create New Order using items from PendingOrder
                 const newOrder = new Order({
                     products: itemsToOrder.map(item => ({
                         product: item.product, // Already ObjectId
                         quantity: item.quantity,
                         size: item.size,
                         // price: item.price // Optionally store price if needed
                     })),
                     payment: {
                         transaction_uuid: esewaOrderId,
                         transaction_code: transaction_code,
                         amount: parseFloat(String(total_amount).replace(/,/g, '')) || 0, // Convert to number
                         status: status, 
                     },
                     buyer: userId,
                     status: 'Processing' 
                 });
                 await newOrder.save();
                 console.log(`[eSewa Success Callback] New order created successfully. Order ID: ${newOrder._id}, Transaction: ${esewaOrderId}`);

                 // --- Decrement Product Stock ---
                 for (const item of itemsToOrder) {
                     try {
                         const product = await productModel.findById(item.product);
                         if (product) {
                             // Ensure stock doesn't go below zero (optional, but good practice)
                             product.quantity = Math.max(0, product.quantity - item.quantity);
                             await product.save();
                             console.log(`[eSewa Success Callback] Decremented stock for product ${item.product} by ${item.quantity}. New stock: ${product.quantity}`);
                         } else {
                             console.warn(`[eSewa Success Callback] Product not found for ID ${item.product} during stock decrement.`);
                         }
                     } catch (stockError) {
                         console.error(`[eSewa Success Callback] Error decrementing stock for product ${item.product}:`, stockError);
                         // Decide how to handle stock update errors (e.g., log and continue, or attempt rollback)
                     }
                 }

                 // 7. Remove **ordered items** from User's Cart
                 const orderedItemIds = new Set(itemsToOrder.map(item => `${item.product}${item.size ? `_${item.size}` : '_'}`));
                 user.cart = user.cart.filter(cartItem => {
                     const cartItemId = `${cartItem.product}${cartItem.size ? `_${cartItem.size}` : '_'}`;
                     return !orderedItemIds.has(cartItemId);
                 });
                 await user.save();
                 console.log(`[eSewa Success Callback] Ordered items removed from user cart for userId: ${userId}. Remaining items: ${user.cart.length}`);

                 // 8. Delete the processed PendingOrder
                 await PendingOrder.deleteOne({ _id: pendingOrder._id });
                 console.log(`[eSewa Success Callback] Deleted pending order ${esewaOrderId}`);

                 // Set redirect URL to homepage on successful order creation
                 finalRedirectUrl = `${clientUrl}/?payment_status=success&orderId=${esewaOrderId}`; 
            }

        } catch (dbError) {
             dbErrorOccurred = true;
             console.error(`[eSewa Success Callback] CRITICAL: DB Error processing order ${esewaOrderId}:`, dbError);
             // Set specific error message for DB issues
              finalRedirectUrl = `${clientUrl}/cart?payment_status=failure&orderId=${esewaOrderId}&message=OrderDatabaseError`;
        }

        // 9. Redirect User
        console.log(`[eSewa Success Callback] FINAL REDIRECT URL: ${finalRedirectUrl}`); 
        res.redirect(finalRedirectUrl);

    } catch (error) {
        // Catch errors before DB processing (e.g., decoding, signature verification)
        console.error("[eSewa Success Callback] Top-level Internal Server Error:", error);
        // Ensure orderId is set if possible before redirecting
        res.redirect(`${clientUrl}/cart?payment_status=failure&orderId=${esewaOrderId}&message=ServerError`);
    }
};


const handleEsewaFailureCallback = async (req, res) => {
    const clientUrl = process.env.CLIENT_URL || 'http://localhost:5173';
    let orderId = 'UNKNOWN';

    try {
        console.log("[eSewa Failure Callback] Received request. Query:", req.query);
        orderId = req.query.oid || req.query.transaction_uuid || 'UNKNOWN'; 
        const esewaRefId = req.query.refId;
        console.log(`[eSewa Failure Callback] Processing failure for Order ID: ${orderId}, eSewa Ref: ${esewaRefId}`);

        console.log(`[eSewa Failure Callback] Redirecting user to frontend CART page for order ${orderId}.`);
        res.redirect(`${clientUrl}/cart?payment_status=failure&orderId=${orderId}&message=PaymentFailedOrCancelled`);

    } catch (error) {
        console.error("[eSewa Failure Callback] Internal Server Error:", error);
        res.redirect(`${clientUrl}/cart?payment_status=failure&orderId=${orderId}&message=ServerError`);
    }
};
module.exports = {
    EsewaInitiatePayment,
    handleEsewaSuccessCallback,
    handleEsewaFailureCallback,
    paymentStatus
};
